/*
    (C) Copyright 2015 CEA LIST. All Rights Reserved.
    Contributor(s): Olivier BICHLER (olivier.bichler@cea.fr)
                    David BRIAND (david.briand@cea.fr)

    This software is governed by the CeCILL-C license under French law and
    abiding by the rules of distribution of free software.  You can  use,
    modify and/ or redistribute the software under the terms of the CeCILL-C
    license as circulated by CEA, CNRS and INRIA at the following URL
    "http://www.cecill.info".

    As a counterpart to the access to the source code and  rights to copy,
    modify and redistribute granted by the license, users are provided only
    with a limited warranty  and the software's author,  the holder of the
    economic rights,  and the successive licensors  have only  limited
    liability.

    The fact that you are presently reading this means that you have had
    knowledge of the CeCILL-C license and that you accept its terms.
*/

#include <chrono>
#include <cstdlib>
#include <cublas_v2.h>
#include <cudnn.h>
#include <dirent.h>
#include <iomanip>
#include <sys/time.h>

// For the Windows version of dirent.h (http://www.softagalleria.net/dirent.php)
#undef min
#undef max

#include "network.hpp"

int main(int argc, char* argv[])
{
    std::string stimulus = "";
    std::string::size_type sz;   // alias of size_t
    unsigned int device = 0;
    unsigned int batchSize = 1;
    double total_time = 0.0;
    float successRate = 0.0;
    std::cout << "Binary automatically generated by the N2D2 platform\n "
                 "-Description: cudnn inference binary export for Deep Neural "
                 "Network.\n"
              << " -Command list:\n"
              << "    Stimulus selection: Use the '-stimulus "
                 "path/to/the/stimulus' command to select a specific input "
                 "stimulus (default value: none)\n"
              << "    Batch size: Use the '-batch xx' to select the batch size "
                 "(default value: 1) \n\n"
              << "This binary  is the exclusive property of the CEA. (C) "
                 "Copyright 2016 CEA LIST\n\n" << std::endl;
    for (int i = 1; i < argc; ++i) {
        const std::string Arg(argv[i]);
        if (Arg.compare("-batch") == 0) {
            std::string::size_type sz; // alias of size_t
            std::string nextArg(argv[i + 1]);
            batchSize = (unsigned)std::stoi(nextArg, &sz);
            std::cout << "Option -batch: Set batch size to " << batchSize
                      << std::endl;
        } else if (Arg.compare("-stimulus") == 0) {
            std::string nextArg(argv[i + 1]);
            stimulus = nextArg;
            std::cout << "Option -stimulus: process the stimulus " << stimulus
                      << std::endl;
        }
        else if (Arg.compare("-dev") == 0) {
            std::string nextArg(argv[i + 1]);
            device = std::stoi(nextArg,&sz);
            std::cout << "Option -dev: process network on the device: "
                      << device
                      << std::endl;
        }
    }

    cudaSetDevice(device);

    unsigned int dimX = 1;
    unsigned int dimY = 1;
    if (OUTPUTS_WIDTH > 1 || OUTPUTS_HEIGHT > 1) {
        dimX = ENV_SIZE_X;
        dimY = ENV_SIZE_Y;
    }

    double yRatio = ENV_SIZE_Y / OUTPUTS_HEIGHT;
    double xRatio = ENV_SIZE_X / OUTPUTS_WIDTH;

    DATA_T* env_data = new DATA_T[ENV_BUFFER_SIZE * batchSize];
    uint32_t* outputEstimated = new uint32_t[OUTPUTS_SIZE * batchSize];
    int32_t* outputTargets = new int32_t[dimX * dimY * batchSize]();
    unsigned int* confusion = new unsigned int[NB_TARGETS * NB_TARGETS]{0};

    cudnnHandle_t context_cudnnHandle;
    cublasHandle_t context_cublasHandle;

    CHECK_CUDNN_STATUS(cudnnCreate(&context_cudnnHandle));
    cublasCreate(&context_cublasHandle);
    init_network(context_cudnnHandle, batchSize);
    std::cout << "NETWORK INITIALIZATION DONE!\n";
    if (!stimulus.empty()) {
        std::cout << "Reading env input " << stimulus << std::endl;
        envRead(stimulus,
                ENV_BUFFER_SIZE,
                ENV_SIZE_Y,
                ENV_SIZE_X,
                env_data,
                dimX * dimY,
                outputTargets);
        network_cudnn(env_data,
                      outputEstimated,
                      context_cudnnHandle,
                      context_cublasHandle,
                      1);
        unsigned int nbIgnored = 0;
        unsigned int nbHits = 0;

        for (unsigned int oy = 0; oy < OUTPUTS_HEIGHT; ++oy) {
            for (unsigned int ox = 0; ox < OUTPUTS_WIDTH; ++ox) {
                int iy = oy;
                int ix = ox;
                if (dimX > 1 || dimY > 1) {
                    iy = (int)floor((oy + 0.5) * yRatio);
                    ix = (int)floor((ox + 0.5) * xRatio);
                }

                const unsigned int oIdx = ox + oy * OUTPUTS_WIDTH;
                const unsigned int Idx = ix + iy * dimX;

                if (outputTargets[Idx] < 0)
                    ++nbIgnored;
                else {
                    const unsigned int confIdx = outputEstimated[oIdx]
                                                 + outputTargets[Idx]
                                                   * NB_TARGETS;
                    confusion[confIdx] += 1;

                    if (outputTargets[Idx] == (int)outputEstimated[oIdx])
                        ++nbHits;
                }
            }
        }

        const double success
            = (OUTPUTS_SIZE > nbIgnored)
                  ? (nbHits / (double)(OUTPUTS_SIZE - nbIgnored))
                  : 1.0;

        printf("Success rate = %02f%%\n", 100.0 * success);
    } else {
        std::string fileName;
        std::vector<std::string> filesList = std::vector<std::string>();
        const std::string dirName = "stimuli";
        getFilesList(dirName, filesList);
        double success = 0;
        unsigned int total = 0;
        double elapsed = 0.0;
        double elapsed_avg = 0.0;
        unsigned int indexFile = 0;
        unsigned int n = batchSize;
        for (std::vector<std::string>::iterator filesIt = filesList.begin(),
                                                itEnd = filesList.end();
             filesIt < itEnd;
             std::advance(filesIt, batchSize)) {

            //-------Extract data from input file---------//
            for (unsigned int i = 0; i < batchSize; i++) {
                if (indexFile >= filesList.size()) {
                    n = i;
                    break;
                }
                fileName = *(filesIt + i);
                envRead(fileName,
                        ENV_BUFFER_SIZE,
                        ENV_SIZE_Y,
                        ENV_SIZE_X,
                        env_data + i * ENV_BUFFER_SIZE,
                        dimX * dimY,
                        &outputTargets[i * dimX * dimY]);
                indexFile++;
            }
            //-------Neural Network---------//
            const std::chrono::high_resolution_clock::time_point start
                = std::chrono::high_resolution_clock::now();
            network_cudnn(env_data,
                          outputEstimated,
                          context_cudnnHandle,
                          context_cublasHandle,
                          batchSize);
            elapsed = 1.0e6 * std::chrono::duration_cast
                              <std::chrono::duration<double> >(
                                  std::chrono::high_resolution_clock::now()
                                  - start).count();
            elapsed_avg += elapsed;
            //---------------------------//
            for (unsigned int i = 0; i < n; i++) {
                unsigned int nbIgnored = 0;
                unsigned int nbHits = 0;
                for (unsigned int oy = 0; oy < OUTPUTS_HEIGHT; ++oy) {
                    for (unsigned int ox = 0; ox < OUTPUTS_WIDTH; ++ox) {
                        int iy = oy;
                        int ix = ox;
                        if (dimX > 1 || dimY > 1) {
                            iy = (int)floor((oy + 0.5) * yRatio);
                            ix = (int)floor((ox + 0.5) * xRatio);
                        }
                        const unsigned int oIdx
                            = ox + oy * OUTPUTS_WIDTH
                              + i * (OUTPUTS_WIDTH * OUTPUTS_HEIGHT);
                        const unsigned int Idx = ix + iy * dimX
                                                 + i * (dimX * dimY);

                        if (outputTargets[Idx] < 0)
                            ++nbIgnored;
                        else {
                            const unsigned int confIdx
                                = (unsigned int)outputEstimated[oIdx]
                                  + outputTargets[Idx] * NB_TARGETS;
                            confusion[confIdx] += 1;
                            if (outputTargets[Idx]
                                == (int)outputEstimated[oIdx]) {
                                ++nbHits;
                            }
                        }
                    }
                }
                success += (OUTPUTS_SIZE > nbIgnored)
                               ? (nbHits / (double)(OUTPUTS_SIZE - nbIgnored))
                               : 1.0;
                ++total;
#ifndef NRET
                printf(
                    "%.02f/%d    (avg = %02f%%) Host process time =  %f Âµs\n",
                    success,
                    total,
                    100.0 * success / (float)total,
                    elapsed / (double)n);
#endif
            }
        }

        std::cout << "---" << std::endl;

#ifdef PROFILING
        double totalProcessTime = 0.0;
        for (std::vector<oclProfiling>::iterator it
             = oclHandles.profiling.begin(),
             itEnd = oclHandles.profiling.end();
             it != itEnd;
             ++it) {
            totalProcessTime += (*it).processTime / (total);
        }

        for (std::vector<oclProfiling>::iterator it
             = oclHandles.profiling.begin(),
             itEnd = oclHandles.profiling.end();
             it != itEnd;
             ++it) {
            const double processTimeUs = (*it).processTime / (total);
            const double workLoad = (processTimeUs / totalProcessTime) * 100.0;
            std::string barrelLoad(((unsigned int)workLoad + 1) * 2, '*');
            std::cout << "(" << std::setfill('0') << std::setw(2)
                      << (unsigned int)workLoad << "%)  " << barrelLoad
                      << "    " << (*it).name << ": " << processTimeUs << " us"
                      << std::endl;
        }
#endif
        total_time = (elapsed_avg / (double)total);
        std::cout << "---" << std::endl;
        std::cout << ESC_BOLD << "Tested " << total << " stimuli" << ESC_ALL_OFF
                  << "\n"
                     "Success rate = " << (100.0 * success / (float)total)
                  << "%\n"
                     "cudNN batch size used: " << batchSize << ESC_ALL_OFF
                  << "\n"
#ifdef PROFILING
                     "Average cudNN process time per stimulus = "
                  << totalProcessTime
                  << " us\n"
#endif
                     "Average elapsed host time per stimulus = " << total_time
                  << " us\n"
                     "Processing frequency = " << std::setprecision(9)
                  << 1 / (total_time * 1.0e-6) << " stimuli/sec" << std::endl;
                  successRate = (100.0 * success / (float)total);
    }

#ifdef OUTXT
    std::ofstream success_result("success_rate.txt");

    if (!success_result.good())
        throw std::runtime_error("Could not create synaptic file:  success_rate.txt");
    success_result << successRate;
    success_result.close();
#endif

    free_memory();
    CHECK_CUDNN_STATUS(cudnnDestroy(context_cudnnHandle));
    cublasDestroy(context_cublasHandle);
    std::cout << "Clear Memory and Destroy cudnnContext done!\n";
    confusion_print(NB_TARGETS, confusion);
    delete[] env_data;
    delete[] outputEstimated;
    delete[] outputTargets;
    delete[] confusion;

}
